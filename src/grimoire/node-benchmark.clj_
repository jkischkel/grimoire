(ns grimoire.node-benchmark
  (:refer-clojure :exclude [send])
  (:use grimoire.node)
  (:import (java.util TimerTask Timer)))

(defn ticker
  [channel]
  (dotimes [i 1000]
    (Thread/sleep 2000)
    (log/info (lamina/closed? channel))
    (lamina/enqueue channel (encode (rand-int 100)))))


(def byte-counter (atom 0))

(defn dump-bytes [bytes]
  (prn (seq bytes)))

(defn measure
  []
  (let [task (proxy [TimerTask] []
               (run []
                 (let [kb (double (/ @byte-counter 1024))]
                   (reset! byte-counter 0)
                   (log/info (format "%.2f" kb) "KB/s"))))]
    (.scheduleAtFixedRate (Timer.) task 0 1000)))

(defn ground-handler [channel client-info]
  (let [rate-channel (rate channel)]
    (lamina/receive-all rate-channel #(log/info % "rps")))
  (lamina/receive-all channel (fn [buffer]
                                (let [msg (decode buffer)]))))

;; (def receive-buffer-size (* 1024 1024 1024))
;; (def send-buffer-size (* 1024 1024 1024))
(def receive-buffer-size (* 1024 1))
(def send-buffer-size (* 1024 1))

(defn netty-options
  []
  {:options {"receiveBufferSize" receive-buffer-size
             "sendBufferSize" send-buffer-size
             "writeBufferHighWaterMark" (* 10 64 1024)
             "receiveBufferSizePredictor"
             (org.jboss.netty.channel.FixedReceiveBufferSizePredictor. receive-buffer-size)}}
;;  {}
  )

(defn start-pb-server [& port]
  ;; (aleph/start-tcp-server echo-handler
  (aleph/start-tcp-server ground-handler
  ;; (aleph/start-tcp-server ground-string-handler
                          {:port (or port 5555),
                           :frame (gloss/finite-block :int32)
                           ;; :frame (gloss/string :utf-8 :delimiters ["\r\n"])
                           ;; :netty (netty-options)
                           :netty {:options {"receiveBufferSize" receive-buffer-size
                                             "sendBufferSize" send-buffer-size
                                             "writeBufferHighWaterMark" (* 10 64 1024)
                                             "receiveBufferSizePredictor"
                                             (org.jboss.netty.channel.FixedReceiveBufferSizePredictor. receive-buffer-size)}}
                           :thread-pool {:min-thread-count 8}
                           })
  ;; (measure)
  )

(defn start-pb-client [& port]
  (lamina/wait-for-result
   (aleph/tcp-client {:host "localhost",
                      :port (or port 5555),
                      :frame (gloss/finite-block :int32)
                      ;; :frame (gloss/string :utf-8 :delimiters ["\r\n"])
                      ;; :netty (netty-options)
                      :netty {:options {"receiveBufferSize" receive-buffer-size
                                        "sendBufferSize" send-buffer-size
                                        "writeBufferHighWaterMark" (* 10 64 1024)
                                        "receiveBufferSizePredictor"
                                        (org.jboss.netty.channel.FixedReceiveBufferSizePredictor. receive-buffer-size)}}
                      })))

(defn nano-time []
  (System/nanoTime))

(defn client-bench
  [client-channel reqs]
  (while true
    ;;(Thread/sleep 1000)
    (let [start-time (nano-time)]
      (dotimes [n reqs]

        (if (lamina/closed? client-channel)
          (do
            (log/info "channel_closed")
            (throw (Exception. "channel_closed")))
          (lamina/enqueue client-channel (encode 123)))

        ;;(let [ch (lamina/enqueue client-channel (encode 123))]
          ;; (log/info "ch closed?" (lamina/closed? ch))
          ;; (lamina/on-error ch (fn []
          ;;                       (log/info "we got a problem")))
        ;;)
        ;; (lamina/enqueue client-channel (str "heysfsdfasdfasdfasdfasdfasdfasdfasdf"))
        )
      ;; (lamina/enqueue client-channel "argh"))
      (let [diff (- (nano-time) start-time)
            time-ms (double (/ diff 1000000))
            time-s (/ time-ms 1000)
            rps (/ reqs time-s)]
        (log/info "took" (format "%.2f" time-ms) "ms -->" (format "%.2f" rps) "req/s")
        ))))

(defn start-client-bench
  [& is-remote]
  (when-not is-remote
    (start-pb-server))
  (let [client-channel (start-pb-client)]
    (lamina/on-error client-channel (fn []
                                      (log/info "we got an error")))
    (lamina/on-closed client-channel (fn []
                                       (log/info "somebody closed the door")))
    (lamina/receive-all client-channel (fn [msg]
                                         (log/info "client received" msg)))
    (future (client-bench client-channel 100000))
    ))


;; send messages to session on remote node
(future
  (Thread/sleep 1000)
  (dotimes [i 1000]
    (send-remote remote-node-name
                 {:type :foo :content {:id 1 :receiver 123}})
    (log/info "sent message")
    (Thread/sleep 1600)))


  ;; (future (sessions/run-bench))

  ;; bench - SERVER
  ;; (when (:start-server options)
  ;;   (do
  ;;     (log/info "starting tcp server")
  ;;     (node/start-pb-server)))

  ;; ;; bench - CLIENT
  ;; (when (:run-benchmark options)
  ;;   (do
  ;;     (log/info "starting tcp client")
  ;;     (node/start-client-bench true)))
